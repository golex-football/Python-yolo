Moonalt Football – Simple ZMQ Instructions (C++ side)
====================================================

GOAL
----
We have one Python worker:

    app/yolo_worker_zmq.py

It can run in two modes:

- --mode zmq  : it RECEIVES raw frames over ZMQ and outputs YOLO results
- --mode obs  : not used by C++ side

For C++ developers there are TWO tasks:

1) Capture card / DeckLink app  ->  send raw frames INTO Python worker
2) BroadTrack (or another app)  ->  receive YOLO output FROM Python worker


----------------------------------------------------
1) RAW FRAMES INTO PYTHON (capture card / DeckLink)
----------------------------------------------------

Python worker (in --mode zmq) expects:

- ZMQ socket type: PULL  (Python side)
- Endpoint      : tcp://127.0.0.1:5555   (default ZMQ_IN_ENDPOINT)

So C++ must:

- Create a PUSH socket
- CONNECT to tcp://127.0.0.1:5555
- For each frame, send a 2-part multipart message:

  Part 0: UTF-8 JSON metadata
  Part 1: raw frame bytes (BGR24)

MESSAGE FORMAT
--------------

Socket:

    zmq::context_t ctx(1);
    zmq::socket_t sock(ctx, ZMQ_PUSH);
    sock.connect("tcp://127.0.0.1:5555");

Per frame (pseudocode):

    // Assume:
    //   int width, height;
    //   std::vector<uint8_t> frame_bgr; // size == width*height*3, BGR24

    nlohmann::json meta;
    meta["schema"]       = "moonalt.raw_frame_v1";
    meta["frame_id"]     = frame_id;          // increasing int
    meta["timestamp_ms"] = unix_ms;          // optional but recommended
    meta["width"]        = width;
    meta["height"]       = height;
    meta["pixel_format"] = "BGR24";

    std::string meta_str = meta.dump();

    zmq::message_t meta_msg(meta_str.size());
    memcpy(meta_msg.data(), meta_str.data(), meta_str.size());

    zmq::message_t frame_msg(frame_bgr.size());
    memcpy(frame_msg.data(), frame_bgr.data(), frame_bgr.size());

    // multipart send: [meta, frame]
    sock.send(meta_msg, zmq::send_flags::sndmore);
    sock.send(frame_msg, zmq::send_flags::none);

Important:

- Pixel format MUST be BGR24 (8-bit, 3 channels, same as OpenCV).
- No resizing in C++ unless you also update width/height accordingly.
- frame_id should be monotonic (0,1,2,…). Python uses it all the way
  through to BroadTrack / Unreal.


---------------------------------------------------------
2) YOLO OUTPUT FROM PYTHON (BroadTrack / any downstream)
---------------------------------------------------------

Python worker OUTPUT:

- ZMQ socket type: PUSH (Python side)
- Endpoint      : tcp://127.0.0.1:5556  (default ZMQ_OUT_ENDPOINT)

So C++ must:

- Create a PULL socket
- CONNECT to tcp://127.0.0.1:5556
- For each frame, receive a 3-part multipart message:

  Part 0: meta JSON (UTF-8)
  Part 1: raw frame bytes  (BGR24)
  Part 2: mask bytes       (GRAY8, 0/255)

Socket:

    zmq::context_t ctx(1);
    zmq::socket_t sock(ctx, ZMQ_PULL);
    sock.connect("tcp://127.0.0.1:5556");

Receive loop (pseudocode):

    while (true) {
        std::vector<zmq::message_t> parts;
        zmq::recv_multipart(sock, std::back_inserter(parts));

        if (parts.size() != 3) {
            // error: expected 3 parts
            continue;
        }

        // --- Part 0: meta JSON ---
        std::string meta_str(static_cast<char*>(parts[0].data()), parts[0].size());
        nlohmann::json meta = nlohmann::json::parse(meta_str);

        int frame_id = meta["frame_id"];
        int width    = meta["width"];
        int height   = meta["height"];
        // meta["bboxes"] is an array of [x1,y1,x2,y2]

        // --- Part 1: raw BGR frame ---
        const uint8_t* frame_data = static_cast<const uint8_t*>(parts[1].data());
        size_t frame_size = parts[1].size(); // should be width*height*3

        // Wrap as cv::Mat (no copy) for BroadTrack/OpenCV:
        cv::Mat frame_bgr(height, width, CV_8UC3, const_cast<uint8_t*>(frame_data));

        // --- Part 2: mask (GRAY8) ---
        const uint8_t* mask_data = static_cast<const uint8_t*>(parts[2].data());
        size_t mask_size = parts[2].size(); // should be width*height

        cv::Mat mask_gray(height, width, CV_8UC1, const_cast<uint8_t*>(mask_data));

        // Now you have:
        //   frame_bgr: raw original frame (unchanged)
        //   mask_gray: segmentation mask (0 = background, 255 = player/ball)
        //   meta["bboxes"]: list of bounding boxes

        // Example: convert bboxes into std::vector<cv::Rect>
        std::vector<cv::Rect> boxes;
        for (auto& bb : meta["bboxes"]) {
            int x1 = bb[0];
            int y1 = bb[1];
            int x2 = bb[2];
            int y2 = bb[3];
            boxes.emplace_back(
                x1, y1,
                x2 - x1,
                y2 - y1
            );
        }

        // Use frame_bgr + boxes for BroadTrack.
        // Use mask_gray if you want player segmentation too.
    }

META JSON FORMAT (YOLO OUTPUT)
------------------------------

Part 0 JSON from Python looks like this:

    {
      "schema":       "moonalt.yolo_output_v1",
      "frame_id":     1234,
      "width":        1920,
      "height":       1080,
      "pixel_format": "BGR24",
      "mask_format":  "GRAY8",
      "bboxes": [
        [x1, y1, x2, y2],
        ...
      ]
    }

Notes:

- frame_id matches the input frame_id from capture side.
- width/height match the raw frame dimensions.
- bboxes coords are in the ORIGINAL resolution (same as frame_bgr).

You can plug these bboxes and/or mask into BroadTrack’s internal flow
instead of reading bbox files from disk.


----------------
SUMMARY FOR C++
----------------

1) Capture card / DeckLink app
   - PUSH socket, connect to tcp://127.0.0.1:5555
   - Send 2-part message per frame:
       Part 0: "moonalt.raw_frame_v1" JSON
       Part 1: raw BGR24 bytes (width*height*3)

2) BroadTrack / downstream
   - PULL socket, connect to tcp://127.0.0.1:5556
   - Receive 3-part message per frame:
       Part 0: "moonalt.yolo_output_v1" JSON (frame_id, width, height, bboxes)
       Part 1: raw BGR24 frame (same as input)
       Part 2: GRAY8 mask (0/255)

If you follow this contract, Python does the heavy ML work and C++ gets a
clean, simple stream of:
    (frame, bboxes, mask, frame_id)
that you can drop into BroadTrack or any other system.
